<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="author" content="Onkar Birajdar" />
    <meta
      name="description"
      content="This is algorithmic Conceptulizer, Will help you to understand the implementaion part of different algorithms. You have different option to copy the code, will let you know the langeuge too "
    />
    <title>Algorithmic Conceptualizer</title>
    <link rel="stylesheet" href="style.css" />
    <link rel="stylesheet" href="prism.css" />
    <script src="prism.js"></script>
  </head>
  <body>
    <nav>
      <header>
        <nav class="navbar">
          <ul>
            <li >
               <img src="File_Icon.png" alt="File_Icon" id="file_icon"> <span id="text">Searching and Sorting Conceptualizer</span> </li>
            <div class="search">
              <input
                type="text"
                id="search"
                name="search"
                title="Search Box"
                placeholder="Search"
              />
            </div>
          </ul>
        </nav>
      </header>
    </nav>
    <div class="container">
      <ol>
        <li>
          Linear Search
          <pre>
              <code class="language-cpp">
                //Here array and x(number to be searched) are input.
                int linear_search(int array[], int x)
                {  
                  for (int i = 0; i < 5; i++)  
                  {    
                    if (array[i] == x)      
                    return i; // 
                  }  
                  return -1;
                }
              </code>
            </pre>
        </li>

        <li>
          Binary search
          <pre>
              <code class="language-cpp">
              //To use this technique the array should be sorted
              int binarySearch(int array[], int x, int low, int high) 
              { // Repeat until the pointers low and high meet each other 
                while (low <= high) 
                { 
                  int mid = (low + high) / 2; 
                  if (array[mid] == x) 
                  {
                    return mid; 
                  }
                  if (array[mid] < x) 
                  {
                    low = mid + 1; 
                  }
                  else
                  {
                    high = mid - 1; 
                  }
                } 
                return -1; 
              }  
  
              </code>
            </pre>
        </li>

        <li>
          <b>Quick Sort</b>
          <pre class="language-cpp">
              <code>
                // A utility function to swap two elements
                void swap(int* a, int* b)
                {
                  int t = *a;
                  *a = *b;
                  *b = t;
                }
                
                /* This function takes last element as pivot, places
                the pivot element at its correct position in sorted
                array, and places all smaller (smaller than pivot)
                to left of pivot and all greater elements to right
                of pivot */
                int partition (int arr[], int low, int high)
                {
                  int pivot = arr[high]; // pivot
                  int i = (low - 1); // Index of smaller element and indicates the right position of pivot found so far
                
                  for (int j = low; j <= high - 1; j++)
                  {
                    // If current element is smaller than the pivot
                    if (arr[j] < pivot)
                    {
                      i++; // increment index of smaller element
                      swap(&arr[i], &arr[j]);
                    }
                  }
                  swap(&arr[i + 1], &arr[high]);
                  return (i + 1);
                }
                
                /* The main function that implements QuickSort
                arr[] --> Array to be sorted,
                low --> Starting index,
                high --> Ending index */
                void quickSort(int arr[], int low, int high)
                {
                  if (low < high)
                  {
                    /* pi is partitioning index, arr[p] is now
                    at right place */
                    int pi = partition(arr, low, high);
                
                    // Separately sort elements before
                    // partition and after partition
                    quickSort(arr, low, pi - 1);
                    quickSort(arr, pi + 1, high);
                  }
                }
          
              </code>
            </pre>
        </li>

        <li>
          <b>Insertion Sort</b>
          <pre class="language-cpp">
              <code>
                /* Function to sort an array using insertion sort*/
                void insertionSort(int arr[], int n)
                {
                    int i, key, j;
                    for (i = 1; i < n; i++)
                    {
                        key = arr[i];
                        j = i - 1;
                 
                        /* Move elements of arr[0..i-1], that are
                        greater than key, to one position ahead
                        of their current position */
                        while (j >= 0 && arr[j] > key)
                        {
                            arr[j + 1] = arr[j];
                            j = j - 1;
                        }
                        arr[j + 1] = key;
                    }
                }
              </code>
            </pre>
        </li>
        <li>
          <b>Merge Sort</b>
          <pre class="language-cpp">
              <code>
                 
// Merges two subarrays of arr[].
// First subarray is arr[l..m]
// Second subarray is arr[m+1..r]
void merge(int arr[], int l, int m, int r)
{
    int n1 = m - l + 1;
    int n2 = r - m;
 
    // Create temp arrays
    int L[n1], R[n2];
 
    // Copy data to temp arrays L[] and R[]
    for (int i = 0; i < n1; i++)
        L[i] = arr[l + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[m + 1 + j];
 
    // Merge the temp arrays back into arr[l..r]
 
    // Initial index of first subarray
    int i = 0;
 
    // Initial index of second subarray
    int j = 0;
 
    // Initial index of merged subarray
    int k = l;
 
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        }
        else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }
 
    // Copy the remaining elements of
    // L[], if there are any
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }
 
    // Copy the remaining elements of
    // R[], if there are any
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}
 
// l is for left index and r is
// right index of the sub-array
// of arr to be sorted */
void mergeSort(int arr[],int l,int r){
    if(l>=r){
        return;//returns recursively
    }
    int m =l+ (r-l)/2;
    mergeSort(arr,l,m);
    mergeSort(arr,m+1,r);
    merge(arr,l,m,r);
}
              </code>
            </pre>
        </li>
        <li>
          <b>Heap Sort</b>
          <pre class="language-cpp">
              <code>
                // To heapify a subtree rooted with node i which is
                // an index in arr[]. n is size of heap
                void heapify(int arr[], int n, int i)
                {
                    int largest = i; // Initialize largest as root
                    int l = 2 * i + 1; // left = 2*i + 1
                    int r = 2 * i + 2; // right = 2*i + 2
                 
                    // If left child is larger than root
                    if (l < n && arr[l] > arr[largest])
                        largest = l;
                 
                    // If right child is larger than largest so far
                    if (r < n && arr[r] > arr[largest])
                        largest = r;
                 
                    // If largest is not root
                    if (largest != i) {
                        swap(arr[i], arr[largest]);
                 
                        // Recursively heapify the affected sub-tree
                        heapify(arr, n, largest);
                    }
                }
                 
                // main function to do heap sort
                void heapSort(int arr[], int n)
                {
                    // Build heap (rearrange array)
                    for (int i = n / 2 - 1; i >= 0; i--)
                        heapify(arr, n, i);
                 
                    // One by one extract an element from heap
                    for (int i = n - 1; i > 0; i--) {
                        // Move current root to end
                        swap(arr[0], arr[i]);
                 
                        // call max heapify on the reduced heap
                        heapify(arr, i, 0);
                    }
                }
              </code>
            </pre>
        </li>
        <li>
          <div>
            <h4>Selection Sort</h4>
          </div>
          <pre>
            <code class="language-cpp">
              void swap(int *xp, int *yp) 
              { 
                  int temp = *xp; 
                  *xp = *yp; 
                  *yp = temp; 
              } 
                
              void selectionSort(int arr[], int n) 
              { 
                  int i, j, min_idx; 
                
                  // One by one move boundary of unsorted subarray 
                  for (i = 0; i < n-1; i++) 
                  { 
                      // Find the minimum element in unsorted array 
                      min_idx = i; 
                      for (j = i+1; j < n; j++) 
                      if (arr[j] < arr[min_idx]) 
                          min_idx = j; 
                
                      // Swap the found minimum element with the first element 
                      swap(&arr[min_idx], &arr[i]); 
                  } 
              } 
            </code>
          </pre>
        </li>
      </ol>
    </div>
  </body>
</html>
